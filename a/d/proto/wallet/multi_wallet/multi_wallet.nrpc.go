// This code was autogenerated from wallet/multi_wallet/multi_wallet.proto, do not edit.
package proto

import (
	"context"
	"log"
	"time"

	"github.com/golang/protobuf/proto"
	nats "github.com/nats-io/go-nats"
	"github.com/nats-rpc/nrpc"
)

// MultiWalletServiceServer is the interface that providers of the service
// MultiWalletService should implement.
type MultiWalletServiceServer interface {
	ChainTip(ctx context.Context, req ChainTipReq) (resp ChainTipResp, err error)
	Deposit(ctx context.Context, req DepositReq) (resp DepositResp, err error)
	Withdraw(ctx context.Context, req WithdrawReq) (resp WithdrawResp, err error)
	GetOmniTransaction(ctx context.Context, req GetOmniTransactionReq) (resp GetOmniTransactionResp, err error)
}

// MultiWalletServiceHandler provides a NATS subscription handler that can serve a
// subscription using a given MultiWalletServiceServer implementation.
type MultiWalletServiceHandler struct {
	ctx     context.Context
	workers *nrpc.WorkerPool
	nc      nrpc.NatsConn
	server  MultiWalletServiceServer
}

func NewMultiWalletServiceHandler(ctx context.Context, nc nrpc.NatsConn, s MultiWalletServiceServer) *MultiWalletServiceHandler {
	return &MultiWalletServiceHandler{
		ctx:    ctx,
		nc:     nc,
		server: s,
	}
}

func NewMultiWalletServiceConcurrentHandler(workers *nrpc.WorkerPool, nc nrpc.NatsConn, s MultiWalletServiceServer) *MultiWalletServiceHandler {
	return &MultiWalletServiceHandler{
		workers: workers,
		nc:      nc,
		server:  s,
	}
}

func (h *MultiWalletServiceHandler) Subject() string {
	return "proto.MultiWalletService.>"
}

func (h *MultiWalletServiceHandler) Handler(msg *nats.Msg) {
	var ctx context.Context
	if h.workers != nil {
		ctx = h.workers.Context
	} else {
		ctx = h.ctx
	}
	request := nrpc.NewRequest(ctx, h.nc, msg.Subject, msg.Reply)
	// extract method name & encoding from subject
	_, _, name, tail, err := nrpc.ParseSubject(
		"proto", 0, "MultiWalletService", 0, msg.Subject)
	if err != nil {
		log.Printf("MultiWalletServiceHanlder: MultiWalletService subject parsing failed: %v", err)
		return
	}

	request.MethodName = name
	request.SubjectTail = tail

	// call handler and form response
	var immediateError *nrpc.Error
	switch name {
	case "ChainTip":
		_, request.Encoding, err = nrpc.ParseSubjectTail(0, request.SubjectTail)
		if err != nil {
			log.Printf("ChainTipHanlder: ChainTip subject parsing failed: %v", err)
			break
		}
		var req ChainTipReq
		if err := nrpc.Unmarshal(request.Encoding, msg.Data, &req); err != nil {
			log.Printf("ChainTipHandler: ChainTip request unmarshal failed: %v", err)
			immediateError = &nrpc.Error{
				Type: nrpc.Error_CLIENT,
				Message: "bad request received: " + err.Error(),
			}
		} else {
			request.Handler = func(ctx context.Context)(proto.Message, error){
				innerResp, err := h.server.ChainTip(ctx, req)
				if err != nil {
					return nil, err
				}
				return &innerResp, err
			}
		}
	case "Deposit":
		_, request.Encoding, err = nrpc.ParseSubjectTail(0, request.SubjectTail)
		if err != nil {
			log.Printf("DepositHanlder: Deposit subject parsing failed: %v", err)
			break
		}
		var req DepositReq
		if err := nrpc.Unmarshal(request.Encoding, msg.Data, &req); err != nil {
			log.Printf("DepositHandler: Deposit request unmarshal failed: %v", err)
			immediateError = &nrpc.Error{
				Type: nrpc.Error_CLIENT,
				Message: "bad request received: " + err.Error(),
			}
		} else {
			request.Handler = func(ctx context.Context)(proto.Message, error){
				innerResp, err := h.server.Deposit(ctx, req)
				if err != nil {
					return nil, err
				}
				return &innerResp, err
			}
		}
	case "Withdraw":
		_, request.Encoding, err = nrpc.ParseSubjectTail(0, request.SubjectTail)
		if err != nil {
			log.Printf("WithdrawHanlder: Withdraw subject parsing failed: %v", err)
			break
		}
		var req WithdrawReq
		if err := nrpc.Unmarshal(request.Encoding, msg.Data, &req); err != nil {
			log.Printf("WithdrawHandler: Withdraw request unmarshal failed: %v", err)
			immediateError = &nrpc.Error{
				Type: nrpc.Error_CLIENT,
				Message: "bad request received: " + err.Error(),
			}
		} else {
			request.Handler = func(ctx context.Context)(proto.Message, error){
				innerResp, err := h.server.Withdraw(ctx, req)
				if err != nil {
					return nil, err
				}
				return &innerResp, err
			}
		}
	case "GetOmniTransaction":
		_, request.Encoding, err = nrpc.ParseSubjectTail(0, request.SubjectTail)
		if err != nil {
			log.Printf("GetOmniTransactionHanlder: GetOmniTransaction subject parsing failed: %v", err)
			break
		}
		var req GetOmniTransactionReq
		if err := nrpc.Unmarshal(request.Encoding, msg.Data, &req); err != nil {
			log.Printf("GetOmniTransactionHandler: GetOmniTransaction request unmarshal failed: %v", err)
			immediateError = &nrpc.Error{
				Type: nrpc.Error_CLIENT,
				Message: "bad request received: " + err.Error(),
			}
		} else {
			request.Handler = func(ctx context.Context)(proto.Message, error){
				innerResp, err := h.server.GetOmniTransaction(ctx, req)
				if err != nil {
					return nil, err
				}
				return &innerResp, err
			}
		}
	default:
		log.Printf("MultiWalletServiceHandler: unknown name %q", name)
		immediateError = &nrpc.Error{
			Type: nrpc.Error_CLIENT,
			Message: "unknown name: " + name,
		}
	}
	if immediateError == nil {
		if h.workers != nil {
			// Try queuing the request
			if err := h.workers.QueueRequest(request); err != nil {
				log.Printf("nrpc: Error queuing the request: %s", err)
			}
		} else {
			// Run the handler synchronously
			request.RunAndReply()
		}
	}

	if immediateError != nil {
		if err := request.SendReply(nil, immediateError); err != nil {
			log.Printf("MultiWalletServiceHandler: MultiWalletService handler failed to publish the response: %s", err)
		}
	} else {
	}
}

type MultiWalletServiceClient struct {
	nc      nrpc.NatsConn
	PkgSubject string
	Subject string
	Encoding string
	Timeout time.Duration
}

func NewMultiWalletServiceClient(nc nrpc.NatsConn) *MultiWalletServiceClient {
	return &MultiWalletServiceClient{
		nc:      nc,
		PkgSubject: "proto",
		Subject: "MultiWalletService",
		Encoding: "protobuf",
		Timeout: 5 * time.Second,
	}
}

func (c *MultiWalletServiceClient) ChainTip(req ChainTipReq) (resp ChainTipResp, err error) {

	subject := c.PkgSubject + "." + c.Subject + "." + "ChainTip"

	// call
	err = nrpc.Call(&req, &resp, c.nc, subject, c.Encoding, c.Timeout)
	if err != nil {
		return // already logged
	}

	return
}

func (c *MultiWalletServiceClient) Deposit(req DepositReq) (resp DepositResp, err error) {

	subject := c.PkgSubject + "." + c.Subject + "." + "Deposit"

	// call
	err = nrpc.Call(&req, &resp, c.nc, subject, c.Encoding, c.Timeout)
	if err != nil {
		return // already logged
	}

	return
}

func (c *MultiWalletServiceClient) Withdraw(req WithdrawReq) (resp WithdrawResp, err error) {

	subject := c.PkgSubject + "." + c.Subject + "." + "Withdraw"

	// call
	err = nrpc.Call(&req, &resp, c.nc, subject, c.Encoding, c.Timeout)
	if err != nil {
		return // already logged
	}

	return
}

func (c *MultiWalletServiceClient) GetOmniTransaction(req GetOmniTransactionReq) (resp GetOmniTransactionResp, err error) {

	subject := c.PkgSubject + "." + c.Subject + "." + "GetOmniTransaction"

	// call
	err = nrpc.Call(&req, &resp, c.nc, subject, c.Encoding, c.Timeout)
	if err != nil {
		return // already logged
	}

	return
}

type Client struct {
	nc      nrpc.NatsConn
	defaultEncoding string
	defaultTimeout time.Duration
	pkgSubject string
	MultiWalletService *MultiWalletServiceClient
}

func NewClient(nc nrpc.NatsConn) *Client {
	c := Client{
		nc: nc,
		defaultEncoding: "protobuf",
		defaultTimeout: 5*time.Second,
		pkgSubject: "proto",
	}
	c.MultiWalletService = NewMultiWalletServiceClient(nc)
	return &c
}

func (c *Client) SetEncoding(encoding string) {
	c.defaultEncoding = encoding
	if c.MultiWalletService != nil {
		c.MultiWalletService.Encoding = encoding
	}
}

func (c *Client) SetTimeout(t time.Duration) {
	c.defaultTimeout = t
	if c.MultiWalletService != nil {
		c.MultiWalletService.Timeout = t
	}
}