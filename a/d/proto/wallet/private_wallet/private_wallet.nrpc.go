// This code was autogenerated from wallet/private_wallet/private_wallet.proto, do not edit.
package proto

import (
	"context"
	"log"
	"time"

	"github.com/golang/protobuf/proto"
	nats "github.com/nats-io/go-nats"
	"github.com/nats-rpc/nrpc"
)

// PrivateWalletServiceServer is the interface that providers of the service
// PrivateWalletService should implement.
type PrivateWalletServiceServer interface {
	ChainTip(ctx context.Context, req ChainTipReq) (resp ChainTipResp, err error)
	Transfer(ctx context.Context, req TransferReq) (resp TransferResp, err error)
	NewAddress(ctx context.Context, req NewAddressReq) (resp AddressResp, err error)
	AddTokenTransaction(ctx context.Context, req TransactionReq) (resp TransactionResp, err error)
	ExecuteTransaction(ctx context.Context, req TransactionReq) (resp TransactionResp, err error)
	DeployToken(ctx context.Context, req DeployTokenReq) (resp AddressResp, err error)
	GetTokenBalance(ctx context.Context, req GetTokenBalanceReq) (resp GetTokenBalanceResp, err error)
	MintToken(ctx context.Context, req TokenReq) (resp TokenResp, err error)
	BurnToken(ctx context.Context, req TokenReq) (resp TokenResp, err error)
}

// PrivateWalletServiceHandler provides a NATS subscription handler that can serve a
// subscription using a given PrivateWalletServiceServer implementation.
type PrivateWalletServiceHandler struct {
	ctx     context.Context
	workers *nrpc.WorkerPool
	nc      nrpc.NatsConn
	server  PrivateWalletServiceServer
}

func NewPrivateWalletServiceHandler(ctx context.Context, nc nrpc.NatsConn, s PrivateWalletServiceServer) *PrivateWalletServiceHandler {
	return &PrivateWalletServiceHandler{
		ctx:    ctx,
		nc:     nc,
		server: s,
	}
}

func NewPrivateWalletServiceConcurrentHandler(workers *nrpc.WorkerPool, nc nrpc.NatsConn, s PrivateWalletServiceServer) *PrivateWalletServiceHandler {
	return &PrivateWalletServiceHandler{
		workers: workers,
		nc:      nc,
		server:  s,
	}
}

func (h *PrivateWalletServiceHandler) Subject() string {
	return "proto.PrivateWalletService.>"
}

func (h *PrivateWalletServiceHandler) Handler(msg *nats.Msg) {
	var ctx context.Context
	if h.workers != nil {
		ctx = h.workers.Context
	} else {
		ctx = h.ctx
	}
	request := nrpc.NewRequest(ctx, h.nc, msg.Subject, msg.Reply)
	// extract method name & encoding from subject
	_, _, name, tail, err := nrpc.ParseSubject(
		"proto", 0, "PrivateWalletService", 0, msg.Subject)
	if err != nil {
		log.Printf("PrivateWalletServiceHanlder: PrivateWalletService subject parsing failed: %v", err)
		return
	}

	request.MethodName = name
	request.SubjectTail = tail

	// call handler and form response
	var immediateError *nrpc.Error
	switch name {
	case "ChainTip":
		_, request.Encoding, err = nrpc.ParseSubjectTail(0, request.SubjectTail)
		if err != nil {
			log.Printf("ChainTipHanlder: ChainTip subject parsing failed: %v", err)
			break
		}
		var req ChainTipReq
		if err := nrpc.Unmarshal(request.Encoding, msg.Data, &req); err != nil {
			log.Printf("ChainTipHandler: ChainTip request unmarshal failed: %v", err)
			immediateError = &nrpc.Error{
				Type: nrpc.Error_CLIENT,
				Message: "bad request received: " + err.Error(),
			}
		} else {
			request.Handler = func(ctx context.Context)(proto.Message, error){
				innerResp, err := h.server.ChainTip(ctx, req)
				if err != nil {
					return nil, err
				}
				return &innerResp, err
			}
		}
	case "Transfer":
		_, request.Encoding, err = nrpc.ParseSubjectTail(0, request.SubjectTail)
		if err != nil {
			log.Printf("TransferHanlder: Transfer subject parsing failed: %v", err)
			break
		}
		var req TransferReq
		if err := nrpc.Unmarshal(request.Encoding, msg.Data, &req); err != nil {
			log.Printf("TransferHandler: Transfer request unmarshal failed: %v", err)
			immediateError = &nrpc.Error{
				Type: nrpc.Error_CLIENT,
				Message: "bad request received: " + err.Error(),
			}
		} else {
			request.Handler = func(ctx context.Context)(proto.Message, error){
				innerResp, err := h.server.Transfer(ctx, req)
				if err != nil {
					return nil, err
				}
				return &innerResp, err
			}
		}
	case "NewAddress":
		_, request.Encoding, err = nrpc.ParseSubjectTail(0, request.SubjectTail)
		if err != nil {
			log.Printf("NewAddressHanlder: NewAddress subject parsing failed: %v", err)
			break
		}
		var req NewAddressReq
		if err := nrpc.Unmarshal(request.Encoding, msg.Data, &req); err != nil {
			log.Printf("NewAddressHandler: NewAddress request unmarshal failed: %v", err)
			immediateError = &nrpc.Error{
				Type: nrpc.Error_CLIENT,
				Message: "bad request received: " + err.Error(),
			}
		} else {
			request.Handler = func(ctx context.Context)(proto.Message, error){
				innerResp, err := h.server.NewAddress(ctx, req)
				if err != nil {
					return nil, err
				}
				return &innerResp, err
			}
		}
	case "AddTokenTransaction":
		_, request.Encoding, err = nrpc.ParseSubjectTail(0, request.SubjectTail)
		if err != nil {
			log.Printf("AddTokenTransactionHanlder: AddTokenTransaction subject parsing failed: %v", err)
			break
		}
		var req TransactionReq
		if err := nrpc.Unmarshal(request.Encoding, msg.Data, &req); err != nil {
			log.Printf("AddTokenTransactionHandler: AddTokenTransaction request unmarshal failed: %v", err)
			immediateError = &nrpc.Error{
				Type: nrpc.Error_CLIENT,
				Message: "bad request received: " + err.Error(),
			}
		} else {
			request.Handler = func(ctx context.Context)(proto.Message, error){
				innerResp, err := h.server.AddTokenTransaction(ctx, req)
				if err != nil {
					return nil, err
				}
				return &innerResp, err
			}
		}
	case "ExecuteTransaction":
		_, request.Encoding, err = nrpc.ParseSubjectTail(0, request.SubjectTail)
		if err != nil {
			log.Printf("ExecuteTransactionHanlder: ExecuteTransaction subject parsing failed: %v", err)
			break
		}
		var req TransactionReq
		if err := nrpc.Unmarshal(request.Encoding, msg.Data, &req); err != nil {
			log.Printf("ExecuteTransactionHandler: ExecuteTransaction request unmarshal failed: %v", err)
			immediateError = &nrpc.Error{
				Type: nrpc.Error_CLIENT,
				Message: "bad request received: " + err.Error(),
			}
		} else {
			request.Handler = func(ctx context.Context)(proto.Message, error){
				innerResp, err := h.server.ExecuteTransaction(ctx, req)
				if err != nil {
					return nil, err
				}
				return &innerResp, err
			}
		}
	case "DeployToken":
		_, request.Encoding, err = nrpc.ParseSubjectTail(0, request.SubjectTail)
		if err != nil {
			log.Printf("DeployTokenHanlder: DeployToken subject parsing failed: %v", err)
			break
		}
		var req DeployTokenReq
		if err := nrpc.Unmarshal(request.Encoding, msg.Data, &req); err != nil {
			log.Printf("DeployTokenHandler: DeployToken request unmarshal failed: %v", err)
			immediateError = &nrpc.Error{
				Type: nrpc.Error_CLIENT,
				Message: "bad request received: " + err.Error(),
			}
		} else {
			request.Handler = func(ctx context.Context)(proto.Message, error){
				innerResp, err := h.server.DeployToken(ctx, req)
				if err != nil {
					return nil, err
				}
				return &innerResp, err
			}
		}
	case "GetTokenBalance":
		_, request.Encoding, err = nrpc.ParseSubjectTail(0, request.SubjectTail)
		if err != nil {
			log.Printf("GetTokenBalanceHanlder: GetTokenBalance subject parsing failed: %v", err)
			break
		}
		var req GetTokenBalanceReq
		if err := nrpc.Unmarshal(request.Encoding, msg.Data, &req); err != nil {
			log.Printf("GetTokenBalanceHandler: GetTokenBalance request unmarshal failed: %v", err)
			immediateError = &nrpc.Error{
				Type: nrpc.Error_CLIENT,
				Message: "bad request received: " + err.Error(),
			}
		} else {
			request.Handler = func(ctx context.Context)(proto.Message, error){
				innerResp, err := h.server.GetTokenBalance(ctx, req)
				if err != nil {
					return nil, err
				}
				return &innerResp, err
			}
		}
	case "MintToken":
		_, request.Encoding, err = nrpc.ParseSubjectTail(0, request.SubjectTail)
		if err != nil {
			log.Printf("MintTokenHanlder: MintToken subject parsing failed: %v", err)
			break
		}
		var req TokenReq
		if err := nrpc.Unmarshal(request.Encoding, msg.Data, &req); err != nil {
			log.Printf("MintTokenHandler: MintToken request unmarshal failed: %v", err)
			immediateError = &nrpc.Error{
				Type: nrpc.Error_CLIENT,
				Message: "bad request received: " + err.Error(),
			}
		} else {
			request.Handler = func(ctx context.Context)(proto.Message, error){
				innerResp, err := h.server.MintToken(ctx, req)
				if err != nil {
					return nil, err
				}
				return &innerResp, err
			}
		}
	case "BurnToken":
		_, request.Encoding, err = nrpc.ParseSubjectTail(0, request.SubjectTail)
		if err != nil {
			log.Printf("BurnTokenHanlder: BurnToken subject parsing failed: %v", err)
			break
		}
		var req TokenReq
		if err := nrpc.Unmarshal(request.Encoding, msg.Data, &req); err != nil {
			log.Printf("BurnTokenHandler: BurnToken request unmarshal failed: %v", err)
			immediateError = &nrpc.Error{
				Type: nrpc.Error_CLIENT,
				Message: "bad request received: " + err.Error(),
			}
		} else {
			request.Handler = func(ctx context.Context)(proto.Message, error){
				innerResp, err := h.server.BurnToken(ctx, req)
				if err != nil {
					return nil, err
				}
				return &innerResp, err
			}
		}
	default:
		log.Printf("PrivateWalletServiceHandler: unknown name %q", name)
		immediateError = &nrpc.Error{
			Type: nrpc.Error_CLIENT,
			Message: "unknown name: " + name,
		}
	}
	if immediateError == nil {
		if h.workers != nil {
			// Try queuing the request
			if err := h.workers.QueueRequest(request); err != nil {
				log.Printf("nrpc: Error queuing the request: %s", err)
			}
		} else {
			// Run the handler synchronously
			request.RunAndReply()
		}
	}

	if immediateError != nil {
		if err := request.SendReply(nil, immediateError); err != nil {
			log.Printf("PrivateWalletServiceHandler: PrivateWalletService handler failed to publish the response: %s", err)
		}
	} else {
	}
}

type PrivateWalletServiceClient struct {
	nc      nrpc.NatsConn
	PkgSubject string
	Subject string
	Encoding string
	Timeout time.Duration
}

func NewPrivateWalletServiceClient(nc nrpc.NatsConn) *PrivateWalletServiceClient {
	return &PrivateWalletServiceClient{
		nc:      nc,
		PkgSubject: "proto",
		Subject: "PrivateWalletService",
		Encoding: "protobuf",
		Timeout: 5 * time.Second,
	}
}

func (c *PrivateWalletServiceClient) ChainTip(req ChainTipReq) (resp ChainTipResp, err error) {

	subject := c.PkgSubject + "." + c.Subject + "." + "ChainTip"

	// call
	err = nrpc.Call(&req, &resp, c.nc, subject, c.Encoding, c.Timeout)
	if err != nil {
		return // already logged
	}

	return
}

func (c *PrivateWalletServiceClient) Transfer(req TransferReq) (resp TransferResp, err error) {

	subject := c.PkgSubject + "." + c.Subject + "." + "Transfer"

	// call
	err = nrpc.Call(&req, &resp, c.nc, subject, c.Encoding, c.Timeout)
	if err != nil {
		return // already logged
	}

	return
}

func (c *PrivateWalletServiceClient) NewAddress(req NewAddressReq) (resp AddressResp, err error) {

	subject := c.PkgSubject + "." + c.Subject + "." + "NewAddress"

	// call
	err = nrpc.Call(&req, &resp, c.nc, subject, c.Encoding, c.Timeout)
	if err != nil {
		return // already logged
	}

	return
}

func (c *PrivateWalletServiceClient) AddTokenTransaction(req TransactionReq) (resp TransactionResp, err error) {

	subject := c.PkgSubject + "." + c.Subject + "." + "AddTokenTransaction"

	// call
	err = nrpc.Call(&req, &resp, c.nc, subject, c.Encoding, c.Timeout)
	if err != nil {
		return // already logged
	}

	return
}

func (c *PrivateWalletServiceClient) ExecuteTransaction(req TransactionReq) (resp TransactionResp, err error) {

	subject := c.PkgSubject + "." + c.Subject + "." + "ExecuteTransaction"

	// call
	err = nrpc.Call(&req, &resp, c.nc, subject, c.Encoding, c.Timeout)
	if err != nil {
		return // already logged
	}

	return
}

func (c *PrivateWalletServiceClient) DeployToken(req DeployTokenReq) (resp AddressResp, err error) {

	subject := c.PkgSubject + "." + c.Subject + "." + "DeployToken"

	// call
	err = nrpc.Call(&req, &resp, c.nc, subject, c.Encoding, c.Timeout)
	if err != nil {
		return // already logged
	}

	return
}

func (c *PrivateWalletServiceClient) GetTokenBalance(req GetTokenBalanceReq) (resp GetTokenBalanceResp, err error) {

	subject := c.PkgSubject + "." + c.Subject + "." + "GetTokenBalance"

	// call
	err = nrpc.Call(&req, &resp, c.nc, subject, c.Encoding, c.Timeout)
	if err != nil {
		return // already logged
	}

	return
}

func (c *PrivateWalletServiceClient) MintToken(req TokenReq) (resp TokenResp, err error) {

	subject := c.PkgSubject + "." + c.Subject + "." + "MintToken"

	// call
	err = nrpc.Call(&req, &resp, c.nc, subject, c.Encoding, c.Timeout)
	if err != nil {
		return // already logged
	}

	return
}

func (c *PrivateWalletServiceClient) BurnToken(req TokenReq) (resp TokenResp, err error) {

	subject := c.PkgSubject + "." + c.Subject + "." + "BurnToken"

	// call
	err = nrpc.Call(&req, &resp, c.nc, subject, c.Encoding, c.Timeout)
	if err != nil {
		return // already logged
	}

	return
}

type Client struct {
	nc      nrpc.NatsConn
	defaultEncoding string
	defaultTimeout time.Duration
	pkgSubject string
	PrivateWalletService *PrivateWalletServiceClient
}

func NewClient(nc nrpc.NatsConn) *Client {
	c := Client{
		nc: nc,
		defaultEncoding: "protobuf",
		defaultTimeout: 5*time.Second,
		pkgSubject: "proto",
	}
	c.PrivateWalletService = NewPrivateWalletServiceClient(nc)
	return &c
}

func (c *Client) SetEncoding(encoding string) {
	c.defaultEncoding = encoding
	if c.PrivateWalletService != nil {
		c.PrivateWalletService.Encoding = encoding
	}
}

func (c *Client) SetTimeout(t time.Duration) {
	c.defaultTimeout = t
	if c.PrivateWalletService != nil {
		c.PrivateWalletService.Timeout = t
	}
}