// This code was autogenerated from backend/account/account.proto, do not edit.
package proto

import (
	"context"
	"log"
	"time"

	"github.com/golang/protobuf/proto"
	nats "github.com/nats-io/go-nats"
	"github.com/nats-rpc/nrpc"
)

// AccountServiceServer is the interface that providers of the service
// AccountService should implement.
type AccountServiceServer interface {
	EosCallback(ctx context.Context, req CallbackReq) (resp BoolResp, err error)
	EthereumCallback(ctx context.Context, req CallbackReq) (resp BoolResp, err error)
	MultiCallback(ctx context.Context, req CallbackReq) (resp BoolResp, err error)
	PrivateErrorCallback(ctx context.Context, req CallbackReq) (resp BoolResp, err error)
	AccountTransfer(ctx context.Context, req AccountTransferReq) (resp BoolResp, err error)
}

// AccountServiceHandler provides a NATS subscription handler that can serve a
// subscription using a given AccountServiceServer implementation.
type AccountServiceHandler struct {
	ctx     context.Context
	workers *nrpc.WorkerPool
	nc      nrpc.NatsConn
	server  AccountServiceServer
}

func NewAccountServiceHandler(ctx context.Context, nc nrpc.NatsConn, s AccountServiceServer) *AccountServiceHandler {
	return &AccountServiceHandler{
		ctx:    ctx,
		nc:     nc,
		server: s,
	}
}

func NewAccountServiceConcurrentHandler(workers *nrpc.WorkerPool, nc nrpc.NatsConn, s AccountServiceServer) *AccountServiceHandler {
	return &AccountServiceHandler{
		workers: workers,
		nc:      nc,
		server:  s,
	}
}

func (h *AccountServiceHandler) Subject() string {
	return "proto.AccountService.>"
}

func (h *AccountServiceHandler) Handler(msg *nats.Msg) {
	var ctx context.Context
	if h.workers != nil {
		ctx = h.workers.Context
	} else {
		ctx = h.ctx
	}
	request := nrpc.NewRequest(ctx, h.nc, msg.Subject, msg.Reply)
	// extract method name & encoding from subject
	_, _, name, tail, err := nrpc.ParseSubject(
		"proto", 0, "AccountService", 0, msg.Subject)
	if err != nil {
		log.Printf("AccountServiceHanlder: AccountService subject parsing failed: %v", err)
		return
	}

	request.MethodName = name
	request.SubjectTail = tail

	// call handler and form response
	var immediateError *nrpc.Error
	switch name {
	case "EosCallback":
		_, request.Encoding, err = nrpc.ParseSubjectTail(0, request.SubjectTail)
		if err != nil {
			log.Printf("EosCallbackHanlder: EosCallback subject parsing failed: %v", err)
			break
		}
		var req CallbackReq
		if err := nrpc.Unmarshal(request.Encoding, msg.Data, &req); err != nil {
			log.Printf("EosCallbackHandler: EosCallback request unmarshal failed: %v", err)
			immediateError = &nrpc.Error{
				Type: nrpc.Error_CLIENT,
				Message: "bad request received: " + err.Error(),
			}
		} else {
			request.Handler = func(ctx context.Context)(proto.Message, error){
				innerResp, err := h.server.EosCallback(ctx, req)
				if err != nil {
					return nil, err
				}
				return &innerResp, err
			}
		}
	case "EthereumCallback":
		_, request.Encoding, err = nrpc.ParseSubjectTail(0, request.SubjectTail)
		if err != nil {
			log.Printf("EthereumCallbackHanlder: EthereumCallback subject parsing failed: %v", err)
			break
		}
		var req CallbackReq
		if err := nrpc.Unmarshal(request.Encoding, msg.Data, &req); err != nil {
			log.Printf("EthereumCallbackHandler: EthereumCallback request unmarshal failed: %v", err)
			immediateError = &nrpc.Error{
				Type: nrpc.Error_CLIENT,
				Message: "bad request received: " + err.Error(),
			}
		} else {
			request.Handler = func(ctx context.Context)(proto.Message, error){
				innerResp, err := h.server.EthereumCallback(ctx, req)
				if err != nil {
					return nil, err
				}
				return &innerResp, err
			}
		}
	case "MultiCallback":
		_, request.Encoding, err = nrpc.ParseSubjectTail(0, request.SubjectTail)
		if err != nil {
			log.Printf("MultiCallbackHanlder: MultiCallback subject parsing failed: %v", err)
			break
		}
		var req CallbackReq
		if err := nrpc.Unmarshal(request.Encoding, msg.Data, &req); err != nil {
			log.Printf("MultiCallbackHandler: MultiCallback request unmarshal failed: %v", err)
			immediateError = &nrpc.Error{
				Type: nrpc.Error_CLIENT,
				Message: "bad request received: " + err.Error(),
			}
		} else {
			request.Handler = func(ctx context.Context)(proto.Message, error){
				innerResp, err := h.server.MultiCallback(ctx, req)
				if err != nil {
					return nil, err
				}
				return &innerResp, err
			}
		}
	case "PrivateErrorCallback":
		_, request.Encoding, err = nrpc.ParseSubjectTail(0, request.SubjectTail)
		if err != nil {
			log.Printf("PrivateErrorCallbackHanlder: PrivateErrorCallback subject parsing failed: %v", err)
			break
		}
		var req CallbackReq
		if err := nrpc.Unmarshal(request.Encoding, msg.Data, &req); err != nil {
			log.Printf("PrivateErrorCallbackHandler: PrivateErrorCallback request unmarshal failed: %v", err)
			immediateError = &nrpc.Error{
				Type: nrpc.Error_CLIENT,
				Message: "bad request received: " + err.Error(),
			}
		} else {
			request.Handler = func(ctx context.Context)(proto.Message, error){
				innerResp, err := h.server.PrivateErrorCallback(ctx, req)
				if err != nil {
					return nil, err
				}
				return &innerResp, err
			}
		}
	case "AccountTransfer":
		_, request.Encoding, err = nrpc.ParseSubjectTail(0, request.SubjectTail)
		if err != nil {
			log.Printf("AccountTransferHanlder: AccountTransfer subject parsing failed: %v", err)
			break
		}
		var req AccountTransferReq
		if err := nrpc.Unmarshal(request.Encoding, msg.Data, &req); err != nil {
			log.Printf("AccountTransferHandler: AccountTransfer request unmarshal failed: %v", err)
			immediateError = &nrpc.Error{
				Type: nrpc.Error_CLIENT,
				Message: "bad request received: " + err.Error(),
			}
		} else {
			request.Handler = func(ctx context.Context)(proto.Message, error){
				innerResp, err := h.server.AccountTransfer(ctx, req)
				if err != nil {
					return nil, err
				}
				return &innerResp, err
			}
		}
	default:
		log.Printf("AccountServiceHandler: unknown name %q", name)
		immediateError = &nrpc.Error{
			Type: nrpc.Error_CLIENT,
			Message: "unknown name: " + name,
		}
	}
	if immediateError == nil {
		if h.workers != nil {
			// Try queuing the request
			if err := h.workers.QueueRequest(request); err != nil {
				log.Printf("nrpc: Error queuing the request: %s", err)
			}
		} else {
			// Run the handler synchronously
			request.RunAndReply()
		}
	}

	if immediateError != nil {
		if err := request.SendReply(nil, immediateError); err != nil {
			log.Printf("AccountServiceHandler: AccountService handler failed to publish the response: %s", err)
		}
	} else {
	}
}

type AccountServiceClient struct {
	nc      nrpc.NatsConn
	PkgSubject string
	Subject string
	Encoding string
	Timeout time.Duration
}

func NewAccountServiceClient(nc nrpc.NatsConn) *AccountServiceClient {
	return &AccountServiceClient{
		nc:      nc,
		PkgSubject: "proto",
		Subject: "AccountService",
		Encoding: "protobuf",
		Timeout: 5 * time.Second,
	}
}

func (c *AccountServiceClient) EosCallback(req CallbackReq) (resp BoolResp, err error) {

	subject := c.PkgSubject + "." + c.Subject + "." + "EosCallback"

	// call
	err = nrpc.Call(&req, &resp, c.nc, subject, c.Encoding, c.Timeout)
	if err != nil {
		return // already logged
	}

	return
}

func (c *AccountServiceClient) EthereumCallback(req CallbackReq) (resp BoolResp, err error) {

	subject := c.PkgSubject + "." + c.Subject + "." + "EthereumCallback"

	// call
	err = nrpc.Call(&req, &resp, c.nc, subject, c.Encoding, c.Timeout)
	if err != nil {
		return // already logged
	}

	return
}

func (c *AccountServiceClient) MultiCallback(req CallbackReq) (resp BoolResp, err error) {

	subject := c.PkgSubject + "." + c.Subject + "." + "MultiCallback"

	// call
	err = nrpc.Call(&req, &resp, c.nc, subject, c.Encoding, c.Timeout)
	if err != nil {
		return // already logged
	}

	return
}

func (c *AccountServiceClient) PrivateErrorCallback(req CallbackReq) (resp BoolResp, err error) {

	subject := c.PkgSubject + "." + c.Subject + "." + "PrivateErrorCallback"

	// call
	err = nrpc.Call(&req, &resp, c.nc, subject, c.Encoding, c.Timeout)
	if err != nil {
		return // already logged
	}

	return
}

func (c *AccountServiceClient) AccountTransfer(req AccountTransferReq) (resp BoolResp, err error) {

	subject := c.PkgSubject + "." + c.Subject + "." + "AccountTransfer"

	// call
	err = nrpc.Call(&req, &resp, c.nc, subject, c.Encoding, c.Timeout)
	if err != nil {
		return // already logged
	}

	return
}

type Client struct {
	nc      nrpc.NatsConn
	defaultEncoding string
	defaultTimeout time.Duration
	pkgSubject string
	AccountService *AccountServiceClient
}

func NewClient(nc nrpc.NatsConn) *Client {
	c := Client{
		nc: nc,
		defaultEncoding: "protobuf",
		defaultTimeout: 5*time.Second,
		pkgSubject: "proto",
	}
	c.AccountService = NewAccountServiceClient(nc)
	return &c
}

func (c *Client) SetEncoding(encoding string) {
	c.defaultEncoding = encoding
	if c.AccountService != nil {
		c.AccountService.Encoding = encoding
	}
}

func (c *Client) SetTimeout(t time.Duration) {
	c.defaultTimeout = t
	if c.AccountService != nil {
		c.AccountService.Timeout = t
	}
}